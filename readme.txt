For milestone 1, Estelle implemented chunking, Saahil completed terrain, and Jesse completed physics.

Chunking - The implementation was pretty cookie-cutter (implementing Chunks as Drawables, assessing whether each face has a neighbor and populating + creating and processing a new interleaved VBO to ultimately render only the faces of each chunk that are touching air, I also implemented the expandTerrainIfNeeded function that renders additional chunks based on the player's position) but I had a lot of bugs: I created the interleaved buffer with alternating positions and colors, which was a problem because the given lambert shader required normals to render (added dummy vectors to represent normals). I had to debug the finer pointer/buffer inputs with teammates and TAs using RenderDoc due to inconsistencies categorizing positions, normals, and colors from the interleaved VBO and correctly apply the model matrix before rendering.

Physics - I had a number of interesting challenges when implementing player physics. First was drag--I implemented my drag in a delta-time sensitive manner which simulates floating on ice when in the air and having a much higher drag constant on the ground then when jumping. Additionally, I chose to give teh player less aerial control of their velocity while jumping instead of giving them no control (which would be physically accurate), for a smoother feeling control system. Had to add a few parameters to the inputbundle to handle other inputs. I tuned the accelerations the player can apply such that it feels relatively smooth without allowing too high of a speed. The actual delta-time itself was relatively uninteresting. For collision, I had to add unique logic to check whether the corner is top/bottom, left/right, etc before applying a modification buffer. This is because without bumping the coordinate values, a floor or ceiling operation isn't necessarily super consistent to what I want, but a decrease in value on a higher-x value corner would work fine but break on the lower-x value corner, while an increase in value would breia the higher-x value corner (that's to say, the corners had opposite buffering direections). The result works well in terms of being smooth to walk into a wall/not getting stuck, and the floor generaly working a well. As for the ray cast from the camera in order to handle placing/destruction, I simply started at the camera and iterated to the next point at which x, y, or z is a whole number (intersection with object) and did necessary calculations there.
