**For milestone 2, Estelle implemented textures, Saahil completed multithreading, and Jesse completed caves.**
## Textures
I first loaded the textures image using code from HW5, and then used my interleaved VBO creation logic from last milestone to split each chunk into a pair of opaque and transparent interleaved VBOs based on their block type and process / render them separately in each part of the pipeline. I indexed the location of each texture in the collective png file and assigned them to vertices/faces using the orientation of each face (for example, grass had different texture slots on its top facem side faces, and bottom). I then implemented animations for water and lava by making a time variable and incrementing it every time the frame updated (60fps). It was difficult to create a function that would create a smoothly looping animation; I experimented with trig and mod functions and ended up with a pretty good function. I also had trouble loading the image and had to debug my texture loading process + ensuring that the vector processing logic in the new system of two VBOs was accurate since some of the numbers ended up off.
## Caves
The Perlin Noise modification was fairly simple, just factoring in the additional vertices (8 total) necessary. For caves, I toyed around with the constants a bit to make sure that they looked nice and things worked well; lava and bedrock were also fairly simple. For the lava/water physics, I decreased player acceleration when they are in the water/lava, and implemented an up velocity on the space button as well. Lastly, for post-processing, I redirected the frame buffer to point to a separate texture, then redrew with post processing effects. I used a uniform variable specifically to handle how much to tint by, before redrawing onto the default frame buffer.

**For milestone 1, Estelle implemented chunking, Saahil completed terrain, and Jesse completed physics.**

## Chunking
The implementation was pretty cookie-cutter (implementing Chunks as Drawables, assessing whether each face has a neighbor and populating + creating and processing a new interleaved VBO to ultimately render only the faces of each chunk that are touching air, I also implemented the expandTerrainIfNeeded function that renders additional chunks based on the player's position) but I had a lot of bugs: I created the interleaved buffer with alternating positions and colors, which was a problem because the given lambert shader required normals to render (added dummy vectors to represent normals). I had to debug the finer pointer/buffer inputs with teammates and TAs using RenderDoc due to inconsistencies categorizing positions, normals, and colors from the interleaved VBO and correctly apply the model matrix before rendering.

## Physics
I had a number of interesting challenges when implementing player physics. First was drag--I implemented my drag in a delta-time sensitive manner which simulates floating on ice when in the air and having a much higher drag constant on the ground then when jumping. Additionally, I chose to give teh player less aerial control of their velocity while jumping instead of giving them no control (which would be physically accurate), for a smoother feeling control system. Had to add a few parameters to the inputbundle to handle other inputs. I tuned the accelerations the player can apply such that it feels relatively smooth without allowing too high of a speed. The actual delta-time itself was relatively uninteresting. For collision, I had to add unique logic to check whether the corner is top/bottom, left/right, etc before applying a modification buffer. This is because without bumping the coordinate values, a floor or ceiling operation isn't necessarily super consistent to what I want, but a decrease in value on a higher-x value corner would work fine but break on the lower-x value corner, while an increase in value would breia the higher-x value corner (that's to say, the corners had opposite buffering direections). The result works well in terms of being smooth to walk into a wall/not getting stuck, and the floor generaly working a well. As for the ray cast from the camera in order to handle placing/destruction, I simply started at the camera and iterated to the next point at which x, y, or z is a whole number (intersection with object) and did necessary calculations there.

## Terrain
For terrain, I followed the general pattern of creating a height field by sampling multiple perlin noise textures. However, I also experimented with creating a cell automata type system to create overhangs and more complex geometry. It didn't work super well, so I have dialed it down for this iteration, but I hope to expand on it in milestone 2. I want to create more overhangs and complex mountain shapes. Other than that, it was a simple application of generating stacked perlin noise. The most difficult part was figuring out the sizing of the noise, because there was no efficient way to test different scales other than trial and error. I didn't use any assistance for this assignment.
