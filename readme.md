**For milestone 1, Estelle implemented chunking, Saahil completed terrain, and Jesse completed physics.**

## Chunking
The implementation was pretty cookie-cutter (implementing Chunks as Drawables, assessing whether each face has a neighbor and populating + creating and processing a new interleaved VBO to ultimately render only the faces of each chunk that are touching air, I also implemented the expandTerrainIfNeeded function that renders additional chunks based on the player's position) but I had a lot of bugs: I created the interleaved buffer with alternating positions and colors, which was a problem because the given lambert shader required normals to render (added dummy vectors to represent normals). I had to debug the finer pointer/buffer inputs with teammates and TAs using RenderDoc due to inconsistencies categorizing positions, normals, and colors from the interleaved VBO and correctly apply the model matrix before rendering.

## Physics
I had a number of interesting challenges when implementing player physics. First was drag--I implemented my drag in a delta-time sensitive manner which simulates floating on ice when in the air and having a much higher drag constant on the ground then when jumping. Additionally, I chose to give teh player less aerial control of their velocity while jumping instead of giving them no control (which would be physically accurate), for a smoother feeling control system. Had to add a few parameters to the inputbundle to handle other inputs. I tuned the accelerations the player can apply such that it feels relatively smooth without allowing too high of a speed. The actual delta-time itself was relatively uninteresting. For collision, I had to add unique logic to check whether the corner is top/bottom, left/right, etc before applying a modification buffer. This is because without bumping the coordinate values, a floor or ceiling operation isn't necessarily super consistent to what I want, but a decrease in value on a higher-x value corner would work fine but break on the lower-x value corner, while an increase in value would breia the higher-x value corner (that's to say, the corners had opposite buffering direections). The result works well in terms of being smooth to walk into a wall/not getting stuck, and the floor generaly working a well. As for the ray cast from the camera in order to handle placing/destruction, I simply started at the camera and iterated to the next point at which x, y, or z is a whole number (intersection with object) and did necessary calculations there.

## Terrain
For terrain, I followed the general pattern of creating a height field by sampling multiple perlin noise textures. However, I also experimented with creating a cell automata type system to create overhangs and more complex geometry. It didn't work super well, so I have dialed it down for this iteration, but I hope to expand on it in milestone 2. I want to create more overhangs and complex mountain shapes. Other than that, it was a simple application of generating stacked perlin noise. The most difficult part was figuring out the sizing of the noise, because there was no efficient way to test different scales other than trial and error. I didn't use any assistance for this assignment.
